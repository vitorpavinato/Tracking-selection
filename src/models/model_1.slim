initialize() {
	//defineConstant("simID",01);
	//defineConstant("seed", 1520476159367);
	//defineConstant("theta", 0.00002);  //2e-4 // theta is sample from prior
	//defineConstant("Ne0", 500);        // Ne0 is calculated as Ne0 = asInteger(theta/(4*mu))
	//defineConstant("Ne1", 30);			 // Ne1 is also sampled from a prior
	defineConstant("SS1", 100);     	    // SS1 = sample size in T=1
	defineConstant("SS2", 100);          // SS2 = sample size in T=2
	//defineConstant("mu", 1e-8);        //  mu = mutation rate - mu=1e-7 for real simulations
	defineConstant("md1", 0.5);          // md1 = dominance for m1 mutations - neutrals
	defineConstant("mf1", 0.0);          // mf1 = fitness for m1 mutations - neutrals
	defineConstant("md2", 0.5);          // md2 = dominance for m2 mutations - benefitials
	defineConstant("mf2", 0.01);          // mf2 = fitness for m2 mutations - benefitials
	defineConstant("mp1", 0.95);          // mp1 = proportion of m1 mutations
	defineConstant("mp2", 0.05); 	       // mp2 = proportion of m2 mutations
	defineConstant("gs", 135e+4);        // gs = genome size
	defineConstant("rr", 4.2e-6);        // rr = recombination rate - 4.2 cM/Mbp * 1e-8
	defineConstant("ts2", 25); 	       // ts2 = time point for the second sampling
	
	//defineConstant("outputpath", "/home/pavinato/My_repositories/Tracking-selection/results/slim_output/");
	
	//setSeed(seed);
	initializeMutationRate(mu);
	initializeMutationType("m1", md1, "f", mf1);
	initializeMutationType("m2", md2, "e", mf2);
	m1.mutationStackPolicy = "s";
	m2.mutationStackPolicy = "s";
	m1.convertToSubstitution = T;
	m2.convertToSubstitution = T;
	initializeGenomicElementType("g1", c(m1,m2), c(mp1,mp2));
	initializeGenomicElement(g1, 0, (gs-1));
	
	//A. thaliana genome size 135Mbp (135,000,000bp) //test 1,350,000bp
	// fragment size;
	k = 1/(2*rr); // k = 11904762

	// number of fragments;
	nf = asInteger(gs/k); // nf = 11

	// Generate a vector for nf fragments upper limits + a vector of rr
	base = NULL;
	rrvc = NULL;
	for(i in 1:(nf-1)) {
		lim = c(i*k-1, i*k);
		base = c(base, lim);
	
		rts = c(rr,0.5);
		rrvc = c(rrvc, rts);
	}

	base = c(base, (gs-1));
	rrvc = c(rrvc, rr);

	initializeRecombinationRate(rrvc, asInteger(base));
}

1 { 	
	
	Ne0 = asInteger(theta/(4*mu));
	sim.addSubpop("p1", Ne0); 
	cat("Theta=" + theta + "\t" + "mu=" + mu + "\t" + "Ne0=" + Ne0 + "\n");

	t1 = Ne0*10;   t1b1 = t1 -2; t1b2 = t1 -1;
	t2 = t1 + ts2; t2b2 = t2 -1;
	
	sim.rescheduleScriptBlock(s1, start=t1b1, end=t1b1);
	sim.rescheduleScriptBlock(s2, start=t1b2, end=t1b2);
	sim.rescheduleScriptBlock(s3, start=t1, end=t1);
	sim.rescheduleScriptBlock(s4, start=t1, end=t1);
	sim.rescheduleScriptBlock(s5, start=t1, end=t1);
	
	sim.rescheduleScriptBlock(s6, start=t2b2, end=t2b2);
	sim.rescheduleScriptBlock(s7, start=t2, end=t2);
	
}

s1 late() {
	m1.convertToSubstitution = F; //the effect of it change affect the next generation
	m2.convertToSubstitution = F;
}

s2 late(){
	CS1 = asInteger(Ne1 + SS1); //the effect of it change affect the next generation - CS1 = Census Size 1
	p1.setSubpopulationSize(CS1);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 1=" + CS1 + "\n");

}

s3 late() {
	
	//tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// tag sampled individuals 
	saminds = sample(sim.subpopulations.individuals, SS1, F);
	saminds.tag = 0;
	
	samindsnames = asString(sapply(seq(from=1, to=SS1), "paste0('indiv' + applyValue + '@pop1');"));

	sammuts = sortBy(unique(saminds.genomes.mutations), "position");
	
	cat("#OUT: " + " " + paste(SS1 + " " +"inds") + " " +"T1" + "\n");
	cat(paste0(outputpath + "slim_output_t1_" + simID + ".txt" + "\n"));
	
	header = paste("chrom"+"\t"+"position"+"\t"+"status"+"\t"+"selection"+"\t"+"alleles"+"\t"+
		 				paste(samindsnames, sep="\t")+"\t"+
		 				"muID"+"\t"+"muDom"+"\t"+"muSel"+"\t"+"muAge"+"\t"+"muFrq1");
	
	tempdata = NULL;
	for (mm in sammuts){
	
		genos = NULL;
		for (si in saminds){

			genome_1 = sortBy(unique(si.genomes[0].mutations), "position");
			genome_2 = sortBy(unique(si.genomes[1].mutations), "position");
		
			hp1 = (asInteger(match(mm.id, genome_1.id)>=0)+1);
			hp2 = (asInteger(match(mm.id, genome_2.id)>=0)+1);
			genotype = paste(hp1 + "" +hp2);
		
			genos = c(genos, genotype);
		
		};
		
		rescaled = sapply(mm.position, "(applyValue +1);");
		mm.setValue("rescaled", rescaled);
				
		chromosome = paste('chr1');
		mm.setValue("chromosome", chromosome);
		
		status = sapply(mm.mutationType, "if (applyValue == m2) paste('NS'); else paste('S');");
		mm.setValue("status", status);
		
		selection = paste("Y");
		mm.setValue("selection", selection);
		
		alleles = paste("A,T");
		mm.setValue("alleles", alleles);

		data = paste(mm.getValue("chromosome")+"\t"+mm.getValue("rescaled")+"\t"+mm.getValue("status")+"\t"+mm.getValue("selection")+"\t"+mm.getValue("alleles")+"\t"+
			 			 paste(genos, sep="\t")+"\t"+
			 			 mm.id+"\t"+mm.mutationType.dominanceCoeff+"\t"+mm.selectionCoeff+"\t"+mm.originGeneration+"\t"+sim.mutationFrequencies(subpops=NULL,mutations=mm));
	
		tempdata = c(tempdata, data);
	};	
   
   dataset = c(header, tempdata);
   writeFile(paste0(outputpath + "slim_output_t1_" + simID + ".txt"), dataset);

}

s4 fitness(NULL){
	//kill sampled individuals
	if (individual.tag == 0)
		return 0.0;
	else
		return relFitness;
}

s5 late(){
	p1.setSubpopulationSize(Ne1); //add this to force sbpopulation size to Ne1
}

s6 late(){
	CS2 = asInteger(Ne1 + SS2); //the effect of it change affect the next generation - CS2 = Census Size 2
	p1.setSubpopulationSize(CS2);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 2=" + CS2 + "\n");

}

s7 late() {
	
	//tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// tag sampled individuals 
	saminds = sample(sim.subpopulations.individuals, SS2, F);
	saminds.tag = 0;
	
	samindsnames = asString(sapply(seq(from=1, to=SS2), "paste0('indiv' + applyValue + '@pop2');"));
	
	sammuts = sortBy(unique(saminds.genomes.mutations), "position");
	
	cat("#OUT: " + " " + paste(SS2 + " " +"inds") + " " +"T2" + "\n");
	cat(paste0(outputpath + "slim_output_t2_" + simID + ".txt" + "\n"));
	
	header = paste("chrom"+"\t"+"position"+"\t"+"status"+"\t"+"selection"+"\t"+"alleles"+"\t"+
		 				paste(samindsnames, sep="\t")+"\t"+
		 				"muID"+"\t"+"muDom"+"\t"+"muSel"+"\t"+"muAge"+"\t"+"muFrq2");
	
	tempdata = NULL;
	for (mm in sammuts){
	
		genos = NULL;
		for (si in saminds){

			genome_1 = sortBy(unique(si.genomes[0].mutations), "position");
			genome_2 = sortBy(unique(si.genomes[1].mutations), "position");
		
			hp1 = (asInteger(match(mm.id, genome_1.id)>=0)+1);
			hp2 = (asInteger(match(mm.id, genome_2.id)>=0)+1);
			genotype = paste(hp1 + "" +hp2);
		
			genos = c(genos, genotype);
		
		};
		
		rescaled = sapply(mm.position, "(applyValue +1);");
		mm.setValue("rescaled", rescaled);
				
		chromosome = paste('chr1');
		mm.setValue("chromosome", chromosome);
				
		status = sapply(mm.mutationType, "if (applyValue == m2) paste('NS'); else paste('S');");
		mm.setValue("status", status);
		
		selection = paste("Y");
		mm.setValue("selection", selection);
		
		alleles = paste("A,T");
		mm.setValue("alleles", alleles);

		data = paste(mm.getValue("chromosome")+"\t"+mm.getValue("rescaled")+"\t"+mm.getValue("status")+"\t"+mm.getValue("selection")+"\t"+mm.getValue("alleles")+"\t"+
			 			 paste(genos, sep="\t")+"\t"+
			 			 mm.id+"\t"+mm.mutationType.dominanceCoeff+"\t"+mm.selectionCoeff+"\t"+mm.originGeneration+"\t"+sim.mutationFrequencies(subpops=NULL,mutations=mm));
	
		tempdata = c(tempdata, data);
	};	
   
   dataset = c(header, tempdata);
   writeFile(paste0(outputpath + "slim_output_t2_" + simID + ".txt"), dataset);
	
	sim.simulationFinished();
}
