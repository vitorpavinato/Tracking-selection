initialize() {
	
	// SIMULATION ID
	//defineConstant("simID",01);
	
	// SET UP SAMPLED VALUES AND USER DEFINED VALUES //
	
	// SAMPLED VALUES //
	
	// Simulation seed number
	//defineConstant("seed", 1529149281572);
	
	// Population Size values
	//defineConstant("mu", 1e-8);        									// mu => mutation rate - mu=1e-7 for real simulations;
	//defineConstant("theta", 0.00004);  									// 2e-4 // theta is sample from prior;
	//defineConstant("Ne1", 1000);		  				   				// Ne1 sampled from a prior;
	
	// Genome-wide Neutral mutations fitness
	defineConstant("fm1", 0.0);        									// fm1 => the fitness for all neutral mutations "m1" - it is fixed with value 0
	defineConstant("fm2", 0.0);       									// fm2 => the fitness for all neutral mutations "m2" - it is fixed with value 0
	
	// Genome-wide Beneficial mutations fitness:
	//defineConstant("gammaM", 0.03); 										// gammaM => the mean of a gamma distribution for the DFE of beneficial mutations "m3";
	//defineConstant("gammak", 0.20);										// gammak => the shaper parameter k (or alpha) for of a gamma distribution for the DFE of beneficial mutations "m3";
	
	//defineConstant("PrGWSel", 0.50);		 								// PrGWSel => the proportion of "GenomicElementType" that contain beneficial mutations drawn from DFE - "g2";
	//defineConstant("prbe", 0.50);      									// prbe => it define the the proportion of beneficial mutations "m3" in the "GenomicElementType" "g2"
	
	// Mutation types dominance
	//defineConstant("dm1", 0.5);       									// dm1 => the dominance for all neutral mutations "m1" - in g1 genomic element2;
	//defineConstant("dm2", 0.5);       									// dm2 => the dominance for all neutral mutations "m2" - in g2 genomic elements;
	//defineConstant("dm3", 0.5);       									// dm3 => the dominance for all beneficial mutations "m3" -  in g2 genomic elements;
	
	// Recombination rate
	//defineConstant("rr", 4.2e-8);     									// rr => the recombination rate define as 4.2 cM/Mbp * 1e-8
		
	// Selfing rate
	//defineConstant("sr", 0.20);       								// self => the selfing rate
	
	// USER DEFINED VALUES //
	
	// Census size and time between samples
	//defineConstant("SS1", 80);     	 									// SS1 => the sample size of the first sampling in T=1
	//defineConstant("SS2", 115);       									// SS2 => the sample size of the second sampling in T=2
	//defineConstant("ts2", 8); 	       									// ts2 => the distance in gerenration from the first sampling
	
	// Genome structure
	//defineConstant("genomeS", 135e+5);									// genomeS => the genome size - A. thaliana genome size is 135Mbp (135,000,000bp) - 135e+6
	//defineConstant("fragS", 4.5e+4);	 									// genS => the "gene" size - 45Kbp
	//defineConstant("chrN", 1);			 								   // ChrN => the number of chromosomes to simulate
	defineConstant("chrS", asInteger((genomeS/chrN)));
	
	// "outputpath" variable will be defined in the main.R script
	//defineConstant("outputpath", "/Users/vitorpavinato/Desktop/");
	
	// INITIALIZE SIMULATION PARAMETERS
	
	//setSeed(seed);
	initializeMutationRate(mu);
	
	// GenomicElementType in the GENOME
	initializeMutationType("m1", dm1, "f", fm1);
	initializeMutationType("m2", dm2, "f", fm2);
	initializeMutationType("m3", dm3, "g", gammaM, gammak);
	m1.mutationStackPolicy = "s";
	m2.mutationStackPolicy = "s";
	m3.mutationStackPolicy = "s";
	m1.convertToSubstitution = T;
	m2.convertToSubstitution = T;
	m3.convertToSubstitution = T;
	initializeGenomicElementType("g1", m1, 1);
	initializeGenomicElementType("g2", c(m2,m3), c((1 - prbe), prbe));
	
	// GENOME's GenomicElementTypes
	
	// Number of the GenomicElementType
	genomicElementN = asInteger((genomeS/fragS));
	
	// Set the STARTS and the ENDS for the initializeGenomicElement
	e_starts = NULL;
	e_ends   = NULL;
	for(i in seq(from = 0, to = genomicElementN-1)) {
		starts    = i*fragS;
		e_starts = c(e_starts, starts);
	
		ends = ((i+1)*fragS)-1;
		e_ends = c(e_ends, ends);
	}

	e_starts = e_starts;
	e_ends   = e_ends;
	
	// Sample the starts/ends pairs to assign each GenomicElementType
	indexes = seq(from = 0, to = (genomicElementN-1));
	g2_idx = sort(sample(indexes, asInteger(PrGWSel*genomicElementN), replace = F));
	
	// Assign each GenomicElementType:
	// g2
	for(i in g2_idx){
		initializeGenomicElement(g2, asInteger(e_starts[i]), asInteger(e_ends[i]));
	}
	// g1
	g1_idx = setDifference(indexes, g2_idx);
	for(j in g1_idx){
		initializeGenomicElement(g1, asInteger(e_starts[j]), asInteger(e_ends[j]));
	}
	
	// RECOMBINATION 
	if (chrN == 1){
		initializeRecombinationRate(rr);
	
	} else {
		chrs_uppers = NULL;
		for(i in seq(from = 1, to = (chrN-1))){
			uppers = c(((i*chrS)-1), (i*chrS));
			chrs_uppers = c(chrs_uppers, uppers);	
		}
		chrs_rrs = rep(c(rr, 0.5), asInteger(size(chrs_uppers)/2));
		
		rr_uppers = c(chrs_uppers, (genomeS-1));
		rr_rates = c(chrs_rrs, rr); 
		initializeRecombinationRate(rr_rates, asInteger(rr_uppers));
	}
}

1 {
	
	Ne0 = asInteger(theta/(4*mu));  // Ne0 is calculated as Ne0 = asInteger(theta/(4*mu));
	
	sim.addSubpop("p1", Ne0);
	cat("Theta=" + theta + "\t" + "mu=" + mu + "\t" + "Ne0= " + Ne0 + "\n");
	
	// Set selfing rate
	//p1.setSelfingRate(sr);
	
	// Set the generations for each event - it schedule script blocks
	t1   = Ne0*10;   // for T=1;
	t1b = t1 -1;  	  // for ONE generation BEFORE T=1;
	t2   = t1 + ts2; // for T=2
	t2b = t2 -1;  	  // for ONE generation BEFORE T=2
	
	sim.rescheduleScriptBlock(s1, start=t1b, end=t1b);
	
	sim.rescheduleScriptBlock(s2, start=t1, end=t1);
	sim.rescheduleScriptBlock(s3, start=t1, end=t1);
	sim.rescheduleScriptBlock(s4, start=t1, end=t1);
	
	sim.rescheduleScriptBlock(s5, start=t2b, end=t2b);
	sim.rescheduleScriptBlock(s6, start=t2, end=t2);
	sim.rescheduleScriptBlock(s7, start=t2, end=t2);
}


s1 late() {
	
	m1.convertToSubstitution = F; //the effect of it change affect the next generation
	m2.convertToSubstitution = F;
	m3.convertToSubstitution = F;

	CS1 = asInteger(Ne1 + SS1); //CS1 = the Census Size of T=1 - the effect of it change affect the next generation - 
	p1.setSubpopulationSize(CS1);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 1=" + CS1 + "\n");
}

s2 late() {
	
	/////////
	// T=1 //
	/////////
	
	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, SS1, F);
	sam_inds.tag = 0;
	
	//////////////////////////////////
	// OUTPUT_1 T=1  - GENETIC DATA //
	//////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS1 + " " +"individuals at:") + " " +"T=1" + "\n");
	cat(paste0(outputpath + "slim_output_t1_" + simID + ".vcf" + "\n"));
	
	// output as a VCF file
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_t1_" + simID + ".vcf"), outputMultiallelics = F);
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it	
}

s3 fitness(NULL) {
	
	// Kill sampled individuals
	if (individual.tag == 0)
		return 0.0;
	else
		return relFitness;
}

s4 late() {
	
	p1.setSubpopulationSize(Ne1); //add this to force sbpopulation size to Ne1
}

s5 late() {
	
	CS2 = asInteger(Ne1 + SS2); //the effect of it change affect the next generation - CS2 = Census Size 2
	p1.setSubpopulationSize(CS2);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 2=" + CS2 + "\n");
}

s6 early() {
	
	//////////////////////////////////
	// OUTPUT_1 T=2  - GENETIC LOAD //
	//////////////////////////////////
	
	if (any(sim.mutations.mutationType == m3)){
		geneticL = paste((max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL)));
	} else {
		geneticL = paste(0);
	}

	writeFile(filePath=paste0(outputpath + "slim_output_load_" + simID + ".txt"), contents=geneticL, append=F);
}

s7 late() {
	
	/////////
	// T=2 //
	/////////
	
	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, SS2, F);
	sam_inds.tag = 0;
	
	//////////////////////////////////
	// OUTPUT_1 T=2  - GENETIC DATA //
	//////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS2 + " " +"individuals at:") + " " +"T=2" + "\n");
	cat(paste0(outputpath + "slim_output_t2_" + simID + ".vcf" + "\n"));
	
	// output as a VCF file
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_t2_" + simID + ".vcf"), outputMultiallelics = F);
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it  
	
	sim.simulationFinished();
}
 
