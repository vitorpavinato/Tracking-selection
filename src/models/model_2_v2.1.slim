initialize() {
	
	// SIMULATION ID
	//defineConstant("simID",01);
	
	// SAMPLED VALUES
	//defineConstant("seed", 1529084066353);
	
	//defineConstant("theta", 0.00004); // 2e-4 // theta is sample from prior;
	//defineConstant("Ne0", 1000);     // Ne0 is calculated as Ne0 = asInteger(theta/(4*mu));
	//defineConstant("Ne1", 30);			 // Ne1 sampled from a prior;
	//defineConstant("mu", 1e-8);       // mu => mutation rate - mu=1e-7 for real simulations;
	
	//defineConstant("gamma2_M", 0.03); // gamma2_M => the mean of a gamma distribution for the DFE of beneficial mutations "m2";
	//defineConstant("gamma2_k", 0.20); // gamma2_k => the shaper parameter k or alpha of the gamma distribution for the DFE of beneficial mutations "m2";
	
	//defineConstant("pge2", 0.50);		 // pge2 => the proportion of "GenomicElementType" "g2" - it contains the mutations "m1" and "m2";
	//defineConstant("mpb", 0.50);      // mpb => the proportion of beneficial mutations "m2" in the "GenomicElementType" "g2", 1-mbp is the proportion of 
	
	
	//defineConstant("rr", 4.2e-8);     // rr => the recombination rate define as 4.2 cM/Mbp * 1e-8
	
	//defineConstant("sr", 0.20);       // self => the selfing rate
	
	// FIXED VALUES
	defineConstant("md1", 0.5);       // md1 => the dominance for all neutral mutations "m1"
	defineConstant("mf1", 0.0);       // mf1 => the fitness for all neutral mutations "m1" - it is fixed with value 0
	defineConstant("md2", 0.5);       // md2 => the dominance for all beneficial mutations "m2"

	//defineConstant("SS1", 80);     	 // SS1 => the sample size of the first sampling in T=1
	//defineConstant("SS2", 115);       // SS2 => the sample size of the second sampling in T=2
	//defineConstant("ts2", 8); 	       // ts2 => the distance in gerenration from the first sampling
	
	defineConstant("genomeS", 135e+6);// genomeS => the genome size - A. thaliana genome size is 135Mbp (135,000,000bp)
	
	defineConstant("chrN", 4);			 // ChrN => the number of chromosomes to simulate
	defineConstant("genN", 4);			 // genN => the number of "genes" to simulate
	defineConstant("genS", 4.5e+4);	 // genS => the "gene" size - 45Kbp
	
	// Obtain the fraction of genome that are going to be divided in chromosomes
	defineConstant("chromosome", asInteger(genomeS - (genN * genS)));
		
	// the "outputpath" variable will be defined in the main.R script
	//defineConstant("outputpath", "/Users/vitorpavinato/Dropbox/PosDoc_INRA_2017/Project/SLiM/SLiM_model_sketch/");
	
	setSeed(seed);
	initializeMutationRate(mu);
	initializeMutationType("m1", md1, "f", mf1);
	initializeMutationType("m2", md2, "g", gamma2_M, gamma2_k);
	m1.mutationStackPolicy = "s";
	m2.mutationStackPolicy = "s";
	m1.convertToSubstitution = T;
	m2.convertToSubstitution = T;
	initializeGenomicElementType("g1", m1, 1);
	initializeGenomicElementType("g2", c(m1,m2), c((1 - mpb), mpb));
	
	// Chromosome size
	chrS = asInteger(chromosome/chrN);
	
	// Number of the GenomicElementType fragments
	nf = asInteger(genomeS/genS); 

	// Set the fragments starts and ends for the initializeGenomicElement
	f_starts = 0;
	f_ends   = NULL;
	for(i in seq(from = 1, to = (nf-1))) {
		stts    = i*genS;
		f_starts = c(f_starts, stts);
	
		end = (i*genS)-1;
		f_ends = c(f_ends, end);
	}

	f_starts = f_starts;
	f_ends   = c(f_ends , (genomeS-1));
	
	// Sample the fragments to assign each GenomicElementType
	indexes = seq(from = 0, to = (nf-1));
	g2_idx = sample(indexes, asInteger(pge2*nf), replace = F);
	
	// Then assign each GenomicElementType
	for(i in g2_idx){
		initializeGenomicElement(g2, asInteger(f_starts[i]), asInteger(f_ends[i]));
	}
	
	g1_idx = setDifference(indexes, g2_idx);
	for(j in g1_idx){
		initializeGenomicElement(g1, asInteger(f_starts[j]), asInteger(f_ends[j]));
	}
	
	//"CHROMOSOMES"
	// Generate a vector for chromosomes upper bounds limits and 0.5 racombination rate limits 
	// Generate also a vector of recombination rates for each chromosome upper limites
	Chr_upper = NULL;
	Chr_rates = NULL;
	for(i in seq(from = 1, to = chrN)) {
		Chr_limits    = c((i*chrS)-2, (i*chrS)-1);
		Chr_upper = c(Chr_upper, Chr_limits);
	
		Chr_rts = c(rr,0.5);
		Chr_rates = c(Chr_rates, Chr_rts);
	}
	
	//"GENES"
	// Generate a vector for genes upper bounds limits and 0.5 racombination rate limits 
	// Generate also a vector of recombination rates for each gene upper limites
	if (genN == 1){
		gene_upper = c((genomeS-1));
		gene_rates = c(rr);
	
	} else {
		gene_upper = NULL;
		gene_rates = NULL;
		for(i in seq(from = 1, to = (genN-1))) {
			gene_limits    = c((i*genS)-2, (i*genS)-1);
			gene_upper = c(gene_upper, gene_limits);
	
			gene_rts = c(rr,0.5);
			gene_rates = c(gene_rates, gene_rts);
		}
		gene_upper = c(chromosome + gene_upper, (genomeS-1));
		gene_rates = c(gene_rates, rr);
	}
	
	// Combine chromosome and gene upper limits
	// Combine chromosome rates and gene rates
	
	upper = c(Chr_upper, gene_upper);
	rates = c(Chr_rates, gene_rates);
	
	// Difine recombination rates
	initializeRecombinationRate(rates, asInteger(upper));
}

1 { 	
	// Set Ne0 based on theta and mu
	Ne0 = asInteger(theta/(4*mu));
	sim.addSubpop("p1", Ne0); 
	cat("Theta=" + theta + "\t" + "mu=" + mu + "\t" + "Ne0= " + Ne0 + "\n");
		
	// Set selfing rate
	//p1.setSelfingRate(sr);
	
	// Set the generations for each event - it schedule script blocks
	t1 = Ne0*10;   // for T=1;
	t1b1 = t1 -2;  // for TWO generation BEFORE T=1;
	t1b2 = t1 -1;  // for ONE generation BEFORE T=1;
	t2 = t1 + ts2; // for T=2
	t2b2 = t2 -1;  // for ONE generation BEFORE T=2
	
	sim.rescheduleScriptBlock(s1, start=t1b1, end=t1b1);
	sim.rescheduleScriptBlock(s2, start=t1b2, end=t1b2);
	sim.rescheduleScriptBlock(s3, start=t1, end=t1);
	sim.rescheduleScriptBlock(s4, start=t1, end=t1);
	sim.rescheduleScriptBlock(s5, start=t1, end=t1);
	
	sim.rescheduleScriptBlock(s6, start=t2b2, end=t2b2);
	sim.rescheduleScriptBlock(s7, start=t2, end=t2);
}

s1 late() {
	m1.convertToSubstitution = F; //the effect of it change affect the next generation
	m2.convertToSubstitution = F;
}

s2 late(){
	CS1 = asInteger(Ne1 + SS1); //CS1 = the Census Size of T=1 - the effect of it change affect the next generation - 
	p1.setSubpopulationSize(CS1);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 1=" + CS1 + "\n");
}

s3 late() {	
	
	/////////
	// T=1 //
	/////////
	
	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, SS1, F);
	sam_inds.tag = 0;
	
	////////////////////////////////////////////////////
	// OUTPUT_1 & 2 T=1 - SWEEP, SELECTION & LOAD DATA//
	////////////////////////////////////////////////////

	// GLOBAL GENETIC LOAD
	L = (max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL));
	
	////////////////////////////
	// POPULATION's MUTATIONS //
	////////////////////////////
	
	// Record all the unique mutations in the population
	pop_muts = sortBy(unique(sim.subpopulations.individuals.genomes.mutations), "position");
	
	// Get TRUE only for all mutations in "GENE" region to subset only these mutations
	pop_muts_in_genes = (pop_muts.position +1) > chromosome;
	pop_genes_muts = pop_muts[pop_muts_in_genes];
	
	///////////////////////
	// SAMPLED MUTATIONS //
	///////////////////////
	
	// Record all the unique mutations in the sampled individuals
	sam_muts = sortBy(unique(sam_inds.genomes.mutations), "position");
	
	// Get TRUE only for all mutations in "GENE" region to subset only these mutations
	sam_muts_in_genes = (sam_muts.position +1) > chromosome;
	sam_genes_muts = sam_muts[sam_muts_in_genes];
	
	// Define "GENE" lower and upper bounds and assign an ID
	if (genN == 1){
		gene_upper = c((genomeS-1));
		gene_lower = c(chromosome);
		
		genes = cbind(gene_lower, gene_upper);
	
		////////////
		// GENE 1 //
		////////////
		
		/////////////////////////
		// SAMPLE's  MUTATIONS //
		/////////////////////////
		
		midpoint_1 = (genes[0] + genes[1])/2;
		dis2midpoint_1 = sapply((sam_genes_muts.position +1), " asInteger(sqrt(((applyValue)-midpoint_1)^2)) ;");
		
		/////////////////////////
		// "SEGRETATION" TABLE //
		/////////////////////////
			
		// Produde the table
		if (!isNULL(dis2midpoint_1)){
			segr_table = paste("chr1" + "\t" + "gene1" + "\t" + (sam_genes_muts.position +1) + "\t" +  midpoint_1 + "\t" + dis2midpoint_1 + "\t" + sam_genes_muts.id + "\t" + sam_genes_muts.selectionCoeff + "\t" + sam_genes_muts.mutationType.dominanceCoeff + "\t" + sam_genes_muts.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=sam_genes_muts) + "\n");
		} else {
			segr_table = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 8), "\t"));
		}
		
		// Prepare the header of the table
		segr_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"midpoint"+"\t"+"d2midpoint"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF1");
		
		// Export the output
		segr_output = c(segr_head, segr_table);
   	writeFile(paste0(outputpath + "slim_segr_output_t1_" + simID + ".txt"), segr_output);

		///////////////////////////////////////
		// POPULATION's BENEFICIAL MUTATIONS //
		///////////////////////////////////////

		//beneficial_muts = pop_genes_muts.selectionCoeff > 0;
		
		///////////////////////
		// "SELECTION" TABLE //
		///////////////////////
		
		// Produde the table
		//if (sum(beneficial_muts) != 0){
		//	sel_table = paste("chr1" + "\t" + "gene1" + "\t" + (pop_genes_muts[beneficial_muts].position +1) + "\t" +  pop_genes_muts[beneficial_muts].id + "\t" + pop_genes_muts[beneficial_muts].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts]) + "\t" + L + "\n");
		//} else {
		//	sel_table = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		//}

		// Prepare the header of the table
		//sel_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF1"+"\t"+"POPload1");
		
		// Export the output
		//sel_output = c(sel_head, sel_table);
   	//writeFile(paste0(outputpath + "slim_sel_output_t1_" + simID + ".txt"), sel_output);	
				
	} else {
		gene_upper = NULL;
		for(i in seq(from = 1, to = (genN-1))) {
			gene_limits    = c((i*genS)-2);
			
			gene_upper = c(gene_upper, gene_limits);
			}
		gene_upper = c(chromosome + gene_upper, (genomeS-1));
		gene_lower = c(chromosome, gene_upper[0:(size(gene_upper)-2)]);
		
		genes = cbind(gene_lower, gene_upper);	
		
		////////////
		// GENE 1 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_1 = ((sam_genes_muts.position +1) < genes[0,1]);
		gene_1 = sam_genes_muts[sam_muts_in_gene_1];
		
		midpoint_1 = (genes[0,0] + genes[0,1])/2;
		dis2midpoint_1 = sapply((gene_1.position +1), " asInteger(sqrt(((applyValue)-midpoint_1)^2)) ;");
							
		
		if (!isNULL(dis2midpoint_1)){
			segr_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + (gene_1.position +1) + "\t" + midpoint_1 + "\t" + dis2midpoint_1 + "\t" + gene_1.id + "\t" + gene_1.selectionCoeff + "\t" + gene_1.mutationType.dominanceCoeff + "\t" + gene_1.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_1), "\n");
		} else {
				segr_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 8), "\t"));
		}
		
		// POPULATION's BENEFICIAL MUTATIONS //

		//beneficial_muts_1 = ((pop_genes_muts.position +1) < genes[0,1] & pop_genes_muts.selectionCoeff > 0);
		
		// Produde the table
		//if (sum(beneficial_muts_1) != 0){
		//	sel_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + (pop_genes_muts[beneficial_muts_1].position +1) + "\t" +  pop_genes_muts[beneficial_muts_1].id + "\t" + pop_genes_muts[beneficial_muts_1].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_1].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_1].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_1]) + "\t" + L, "\n");
		//} else {
		//	sel_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		//}

		////////////
		// GENE 2 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_2 = ((sam_genes_muts.position +1) > genes[1,0] & (sam_genes_muts.position +1) < genes[1,1]);
		gene_2 = sam_genes_muts[sam_muts_in_gene_2];
		
		midpoint_2 = (genes[1,0] + genes[1,1])/2;
		dis2midpoint_2 = sapply((gene_2.position +1), " asInteger(sqrt(((applyValue)-midpoint_2)^2)) ;");
				
		if (!isNULL(dis2midpoint_2)){
			segr_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + (gene_2.position +1) + "\t" + midpoint_2 + "\t" + dis2midpoint_2 + "\t" + gene_2.id + "\t" + gene_2.selectionCoeff + "\t" + gene_2.mutationType.dominanceCoeff + "\t" + gene_2.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_2), "\n");	
		} else {
			segr_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + paste(rep("NA", 8), "\t"));
		}	
		
		// POPULATION's BENEFICIAL MUTATIONS //

		//beneficial_muts_2 = ((pop_genes_muts.position +1) > genes[1,0] & (pop_genes_muts.position +1) < genes[1,1] & pop_genes_muts.selectionCoeff > 0);
				
		// Produde the table
		//if (sum(beneficial_muts_2) != 0){
		//	sel_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + (pop_genes_muts[beneficial_muts_2].position +1) + "\t" +  pop_genes_muts[beneficial_muts_2].id + "\t" + pop_genes_muts[beneficial_muts_2].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_2].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_2].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_2]) + "\t" + L, "\n");
		//} else {
		//	sel_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		//}
	
		////////////
		// GENE 3 //
		////////////

		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_3 = ((sam_genes_muts.position +1) > genes[2,0] & (sam_genes_muts.position +1) < genes[2,1]);
		gene_3 = sam_genes_muts[sam_muts_in_gene_3];
		
		midpoint_3 = (genes[2,0] + genes[2,1])/2;
		dis2midpoint_3 = sapply((gene_3.position +1), " asInteger(sqrt(((applyValue)-midpoint_3)^2)) ;");
		
		if (!isNULL(dis2midpoint_3)){
			segr_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + (gene_3.position +1) + "\t" + midpoint_3 + "\t" + dis2midpoint_3 + "\t" + gene_3.id + "\t" + gene_3.selectionCoeff + "\t" + gene_3.mutationType.dominanceCoeff + "\t" + gene_3.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_3), "\n");
		} else {
			segr_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + paste(rep("NA", 8), "\t"));
		}	
		
		// POPULATION's BENEFICIAL MUTATIONS //

		//beneficial_muts_3 = ((pop_genes_muts.position +1) > genes[2,0] & (pop_genes_muts.position +1) < genes[2,1] & pop_genes_muts.selectionCoeff > 0);
		
		// Produde the table
		//if (sum(beneficial_muts_3) != 0){
			//sel_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + (pop_genes_muts[beneficial_muts_3].position +1) + "\t" +  pop_genes_muts[beneficial_muts_3].id + "\t" + pop_genes_muts[beneficial_muts_3].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_3].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_3].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_3]) + "\t" + L, "\n");
		//} else {
		//	sel_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		//}

		////////////
		// GENE 4 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_4 = ((sam_genes_muts.position +1) > genes[(size(gene_upper)-1),0]);
		gene_4 = sam_genes_muts[sam_muts_in_gene_4];
		
		midpoint_4 = (genes[3,0] + genes[3,1])/2;
		dis2midpoint_4 = sapply((gene_4.position +1), " asInteger(sqrt(((applyValue)-midpoint_4)^2)) ;");
		
		/////////////////////////
		// "SEGRETATION" TABLE //
		/////////////////////////
		
		if (!isNULL(dis2midpoint_4)){
			segr_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + (gene_4.position +1) + "\t" + midpoint_4 + "\t" + dis2midpoint_4 + "\t" + gene_4.id + "\t" + gene_4.selectionCoeff + "\t" + gene_4.mutationType.dominanceCoeff + "\t" + gene_4.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_4), "\n");
		} else {
			segr_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + paste(rep("NA", 8), "\t"));
		}			 	 	
	
		segr_table = c(segr_gene_1, segr_gene_2, segr_gene_3, segr_gene_4);
		
		// Prepare the header of the table
		segr_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"midpoint"+"\t"+"d2midpoint"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF1");
		
		// Export the output
		segr_output = c(segr_head, segr_table);
   	writeFile(paste0(outputpath + "slim_segr_output_t1_" + simID + ".txt"), segr_output);
	
		// POPULATION's BENEFICIAL MUTATIONS //

		//beneficial_muts_4 = ((pop_genes_muts.position +1) > genes[(size(gene_upper)-1),0] & pop_genes_muts.selectionCoeff > 0);
		
		///////////////////////
		// "SELECTION" TABLE //
		///////////////////////
		
		// Produde the table
		//if (sum(beneficial_muts_4) != 0){
		//	sel_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + (pop_genes_muts[beneficial_muts_4].position +1) + "\t" +  pop_genes_muts[beneficial_muts_4].id + "\t" + pop_genes_muts[beneficial_muts_4].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_4].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_4].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_4]) + "\t" + L, "\n");
		//} else {
		//	sel_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		//}
		
		//sel_table = c(sel_gene_1, sel_gene_2, sel_gene_3, sel_gene_4);
		
		// Prepare the header of the table
		//sel_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF1"+"\t"+"POPload1");
		
		// Export the output
		//sel_output = c(sel_head, sel_table);
   	//writeFile(paste0(outputpath + "slim_sel_output_t1_" + simID + ".txt"), sel_output);	
	
	}
	
	//////////////////////////////////
	// OUTPUT_3 T=1  - GENETIC DATA //
	//////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS1 + " " +"individuals at:") + " " +"T=1" + "\n");
	cat(paste0(outputpath + "slim_output_t1_" + simID + ".vcf" + "\n"));
	
	// output as a VCF file
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_t1_" + simID + ".vcf"), outputMultiallelics = F); 
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it
	
}

s4 fitness(NULL){
	// Kill sampled individuals
	if (individual.tag == 0)
		return 0.0;
	else
		return relFitness;
}

s5 late(){
	p1.setSubpopulationSize(Ne1); //add this to force sbpopulation size to Ne1
}

s6 late(){
	CS2 = asInteger(Ne1 + SS2); //the effect of it change affect the next generation - CS2 = Census Size 2
	p1.setSubpopulationSize(CS2);
	cat("Ne1=" + Ne1 + "\t" + "Census Size 2=" + CS2 + "\n");
}

s7 late() {
	
	/////////
	// T=2 //
	/////////
	
	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, SS1, F);
	sam_inds.tag = 0;
	
	////////////////////////////////////////////////////
	// OUTPUT_1 & 2 T=2 - SWEEP, SELECTION & LOAD DATA//
	////////////////////////////////////////////////////

	// GLOBAL GENETIC LOAD
	L = (max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL));
	
	////////////////////////////
	// POPULATION's MUTATIONS //
	////////////////////////////
	
	// Record all the unique mutations in the population
	pop_muts = sortBy(unique(sim.subpopulations.individuals.genomes.mutations), "position");
	
	// Get TRUE only for all mutations in "GENE" region to subset only these mutations
	pop_muts_in_genes = (pop_muts.position +1) > chromosome;
	pop_genes_muts = pop_muts[pop_muts_in_genes];
	
	///////////////////////
	// SAMPLED MUTATIONS //
	///////////////////////
	
	// Record all the unique mutations in the sampled individuals
	sam_muts = sortBy(unique(sam_inds.genomes.mutations), "position");
	
	// Get TRUE only for all mutations in "GENE" region to subset only these mutations
	sam_muts_in_genes = (sam_muts.position +1) > chromosome;
	sam_genes_muts = sam_muts[sam_muts_in_genes];
	
	// Define "GENE" lower and upper bounds and assign an ID
	if (genN == 1){
		gene_upper = c((genomeS-1));
		gene_lower = c(chromosome);
		
		genes = cbind(gene_lower, gene_upper);
	
		////////////
		// GENE 1 //
		////////////
		
		/////////////////////////
		// SAMPLE's  MUTATIONS //
		/////////////////////////
		
		midpoint_1 = (genes[0] + genes[1])/2;
		dis2midpoint_1 = sapply((sam_genes_muts.position +1), " asInteger(sqrt(((applyValue)-midpoint_1)^2)) ;");
		
		/////////////////////////
		// "SEGRETATION" TABLE //
		/////////////////////////
			
		// Produde the table
		if (!isNULL(dis2midpoint_1)){
			segr_table = paste("chr1" + "\t" + "gene1" + "\t" + (sam_genes_muts.position +1) + "\t" +  midpoint_1 + "\t" + dis2midpoint_1 + "\t" + sam_genes_muts.id + "\t" + sam_genes_muts.selectionCoeff + "\t" + sam_genes_muts.mutationType.dominanceCoeff + "\t" + sam_genes_muts.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=sam_genes_muts) + "\n");
		} else {
			segr_table = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 8), "\t"));
		}
		
		// Prepare the header of the table
		segr_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"midpoint"+"\t"+"d2midpoint"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF2");
		
		// Export the output
		segr_output = c(segr_head, segr_table);
   	writeFile(paste0(outputpath + "slim_segr_output_t2_" + simID + ".txt"), segr_output);

		///////////////////////////////////////
		// POPULATION's BENEFICIAL MUTATIONS //
		///////////////////////////////////////

		beneficial_muts = pop_genes_muts.selectionCoeff > 0;
		
		///////////////////////
		// "SELECTION" TABLE //
		///////////////////////
		
		// Produde the table
		if (sum(beneficial_muts) != 0){
			sel_table = paste("chr1" + "\t" + "gene1" + "\t" + (pop_genes_muts[beneficial_muts].position +1) + "\t" +  pop_genes_muts[beneficial_muts].id + "\t" + pop_genes_muts[beneficial_muts].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts]) + "\t" + L + "\n");
		} else {
			sel_table = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		}

		// Prepare the header of the table
		sel_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF2"+"\t"+"POPload2");
		
		// Export the output
		sel_output = c(sel_head, sel_table);
   	writeFile(paste0(outputpath + "slim_sel_output_t2_" + simID + ".txt"), sel_output);	
				
	} else {
		gene_upper = NULL;
		for(i in seq(from = 1, to = (genN-1))) {
			gene_limits    = c((i*genS)-2);
			
			gene_upper = c(gene_upper, gene_limits);
			}
		gene_upper = c(chromosome + gene_upper, (genomeS-1));
		gene_lower = c(chromosome, gene_upper[0:(size(gene_upper)-2)]);
		
		genes = cbind(gene_lower, gene_upper);	
		
		////////////
		// GENE 1 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_1 = ((sam_genes_muts.position +1) < genes[0,1]);
		gene_1 = sam_genes_muts[sam_muts_in_gene_1];
		
		midpoint_1 = (genes[0,0] + genes[0,1])/2;
		dis2midpoint_1 = sapply((gene_1.position +1), " asInteger(sqrt(((applyValue)-midpoint_1)^2)) ;");
							
		
		if (!isNULL(dis2midpoint_1)){
			segr_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + (gene_1.position +1) + "\t" + midpoint_1 + "\t" + dis2midpoint_1 + "\t" + gene_1.id + "\t" + gene_1.selectionCoeff + "\t" + gene_1.mutationType.dominanceCoeff + "\t" + gene_1.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_1), "\n");
		} else {
				segr_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 8), "\t"));
		}
		
		// POPULATION's BENEFICIAL MUTATIONS //

		beneficial_muts_1 = ((pop_genes_muts.position +1) < genes[0,1] & pop_genes_muts.selectionCoeff > 0);
		
		// Produde the table
		if (sum(beneficial_muts_1) != 0){
			sel_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + (pop_genes_muts[beneficial_muts_1].position +1) + "\t" +  pop_genes_muts[beneficial_muts_1].id + "\t" + pop_genes_muts[beneficial_muts_1].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_1].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_1].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_1]) + "\t" + L, "\n");
		} else {
			sel_gene_1 = paste("chr1" + "\t" + "gene1" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		}

		////////////
		// GENE 2 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_2 = ((sam_genes_muts.position +1) > genes[1,0] & (sam_genes_muts.position +1) < genes[1,1]);
		gene_2 = sam_genes_muts[sam_muts_in_gene_2];
		
		midpoint_2 = (genes[1,0] + genes[1,1])/2;
		dis2midpoint_2 = sapply((gene_2.position +1), " asInteger(sqrt(((applyValue)-midpoint_2)^2)) ;");
				
		if (!isNULL(dis2midpoint_2)){
			segr_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + (gene_2.position +1) + "\t" + midpoint_2 + "\t" + dis2midpoint_2 + "\t" + gene_2.id + "\t" + gene_2.selectionCoeff + "\t" + gene_2.mutationType.dominanceCoeff + "\t" + gene_2.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_2), "\n");	
		} else {
			segr_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + paste(rep("NA", 8), "\t"));
		}	
		
		// POPULATION's BENEFICIAL MUTATIONS //

		beneficial_muts_2 = ((pop_genes_muts.position +1) > genes[1,0] & (pop_genes_muts.position +1) < genes[1,1] & pop_genes_muts.selectionCoeff > 0);
				
		// Produde the table
		if (sum(beneficial_muts_2) != 0){
			sel_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + (pop_genes_muts[beneficial_muts_2].position +1) + "\t" +  pop_genes_muts[beneficial_muts_2].id + "\t" + pop_genes_muts[beneficial_muts_2].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_2].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_2].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_2]) + "\t" + L, "\n");
		} else {
			sel_gene_2 = paste("chr1" + "\t" + "gene2" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		}
	
		////////////
		// GENE 3 //
		////////////

		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_3 = ((sam_genes_muts.position +1) > genes[2,0] & (sam_genes_muts.position +1) < genes[2,1]);
		gene_3 = sam_genes_muts[sam_muts_in_gene_3];
		
		midpoint_3 = (genes[2,0] + genes[2,1])/2;
		dis2midpoint_3 = sapply((gene_3.position +1), " asInteger(sqrt(((applyValue)-midpoint_3)^2)) ;");
		
		if (!isNULL(dis2midpoint_3)){
			segr_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + (gene_3.position +1) + "\t" + midpoint_3 + "\t" + dis2midpoint_3 + "\t" + gene_3.id + "\t" + gene_3.selectionCoeff + "\t" + gene_3.mutationType.dominanceCoeff + "\t" + gene_3.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_3), "\n");
		} else {
			segr_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + paste(rep("NA", 8), "\t"));
		}	
		
		// POPULATION's BENEFICIAL MUTATIONS //

		beneficial_muts_3 = ((pop_genes_muts.position +1) > genes[2,0] & (pop_genes_muts.position +1) < genes[2,1] & pop_genes_muts.selectionCoeff > 0);
		
		// Produde the table
		if (sum(beneficial_muts_3) != 0){
			sel_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + (pop_genes_muts[beneficial_muts_3].position +1) + "\t" +  pop_genes_muts[beneficial_muts_3].id + "\t" + pop_genes_muts[beneficial_muts_3].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_3].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_3].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_3]) + "\t" + L, "\n");
		} else {
			sel_gene_3 = paste("chr1" + "\t" + "gene3" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		}

		////////////
		// GENE 4 //
		////////////
		
		// SAMPLE's  MUTATIONS //
		
		sam_muts_in_gene_4 = ((sam_genes_muts.position +1) > genes[(size(gene_upper)-1),0]);
		gene_4 = sam_genes_muts[sam_muts_in_gene_4];
		
		midpoint_4 = (genes[3,0] + genes[3,1])/2;
		dis2midpoint_4 = sapply((gene_4.position +1), " asInteger(sqrt(((applyValue)-midpoint_4)^2)) ;");
		
		/////////////////////////
		// "SEGRETATION" TABLE //
		/////////////////////////
		
		if (!isNULL(dis2midpoint_4)){
			segr_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + (gene_4.position +1) + "\t" + midpoint_4 + "\t" + dis2midpoint_4 + "\t" + gene_4.id + "\t" + gene_4.selectionCoeff + "\t" + gene_4.mutationType.dominanceCoeff + "\t" + gene_4.originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=gene_4), "\n");
		} else {
			segr_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + paste(rep("NA", 8), "\t"));
		}			 	 	
	
		segr_table = c(segr_gene_1, segr_gene_2, segr_gene_3, segr_gene_4);
		
		// Prepare the header of the table
		segr_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"midpoint"+"\t"+"d2midpoint"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF2");
		
		// Export the output
		segr_output = c(segr_head, segr_table);
   	writeFile(paste0(outputpath + "slim_segr_output_t2_" + simID + ".txt"), segr_output);
	
		// POPULATION's BENEFICIAL MUTATIONS //

		beneficial_muts_4 = ((pop_genes_muts.position +1) > genes[(size(gene_upper)-1),0] & pop_genes_muts.selectionCoeff > 0);
		
		///////////////////////
		// "SELECTION" TABLE //
		///////////////////////
		
		// Produde the table
		if (sum(beneficial_muts_4) != 0){
			sel_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + (pop_genes_muts[beneficial_muts_4].position +1) + "\t" +  pop_genes_muts[beneficial_muts_4].id + "\t" + pop_genes_muts[beneficial_muts_4].selectionCoeff + "\t" + pop_genes_muts[beneficial_muts_4].mutationType.dominanceCoeff + "\t" + pop_genes_muts[beneficial_muts_4].originGeneration + "\t" + sim.mutationFrequencies(subpops=NULL,mutations=pop_genes_muts[beneficial_muts_4]) + "\t" + L, "\n");
		} else {
			sel_gene_4 = paste("chr1" + "\t" + "gene4" + "\t" + paste(rep("NA", 6), "\t") + "\t" + L);
		}
		
		sel_table = c(sel_gene_1, sel_gene_2, sel_gene_3, sel_gene_4);
		
		// Prepare the header of the table
		sel_head = paste("chrom"+"\t"+"gene"+"\t"+"position"+"\t"+"MID"+"\t"+"S"+"\t"+"DOM"+"\t"+"GO"+"\t"+"MF2"+"\t"+"POPload2");
		
		// Export the output
		sel_output = c(sel_head, sel_table);
   	writeFile(paste0(outputpath + "slim_sel_output_t2_" + simID + ".txt"), sel_output);	
	
	}
	
	//////////////////////////////////
	// OUTPUT_3 T=2  - GENETIC DATA //
	//////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS2 + " " +"individuals at:") + " " +"T=2" + "\n");
	cat(paste0(outputpath + "slim_output_t2_" + simID + ".vcf" + "\n"));
	
	// output as a VCF file
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_t2_" + simID + ".vcf"), outputMultiallelics = F); 
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it   
	
	sim.simulationFinished();
}
