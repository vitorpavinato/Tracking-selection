function (io)countGametes(io$ x)
	{
		n = sum(sim.subpopulations.individuals.pedigreeParentIDs == x);
		return n;	
	}
	
	
initialize() {
	
	// Genome-wide Neutral mutations fitness
	defineConstant("fm1", 0.0);        									// fm1 => the fitness for all neutral mutations "m1" - it is fixed with value 0;
	defineConstant("fm2", 0.0);       									// fm2 => the fitness for all neutral mutations "m2" - it is fixed with value 0;
	defineConstant("fm4", 0.0);       									// fm4 => the fitness for all neutral mutations "m4" - it is fixed with value 0;
	
	// INITIALIZE SIMULATION PARAMETERS
	
	initializeSLiMOptions(keepPedigrees = T);
	initializeTreeSeq();
	initializeMutationRate(mu);
	
	// Define the GenomicElementType in the GENOME
	initializeMutationType("m1", dm1, "f", fm1);
	initializeMutationType("m2", dm2, "f", fm2);
	initializeMutationType("m3", dm3, "g", gammaM, gammak);
	m1.mutationStackPolicy = "s";
	m2.mutationStackPolicy = "s";
	m3.mutationStackPolicy = "s";
	m1.convertToSubstitution = T;
	m2.convertToSubstitution = T;
	m3.convertToSubstitution = T;
	initializeGenomicElementType("g1", m1, 1);
	initializeGenomicElementType("g2", c(m2,m3), c((1 - prbe), prbe));
	
	// Define the GenomicElementType in the EXTRA CHROMOSOME
	initializeMutationType("m4", dm4, "f", fm4);
	m4.mutationStackPolicy = "s";
	m4.convertToSubstitution = T;
	initializeGenomicElementType("g3", m4, 1);
	
	// GENOME's GenomicElementTypes
	
	// Assign each GenomicElementType:
	// g2
	for(i in g2_idx){
		initializeGenomicElement(g2, asInteger(e_starts[i]), asInteger(e_ends[i]));
	}
	// g1
	for(j in g1_idx){
		initializeGenomicElement(g1, asInteger(e_starts[j]), asInteger(e_ends[j]));
	}
	
	// EXTRA CHROMOSOME's GenomicElementTypes	
	initializeGenomicElement(g3, genomeS, asInteger((genomeS + chrS)-1));
		
	defineConstant("RECOMBRATES", "initializeRecombinationRate(rr_rates, asInteger(rr_limits));");
	executeLambda(RECOMBRATES);
}

1 {
	sim.readFromPopulationFile(filePath=paste0(outputpath + "slim_coalesced_BS_" + simID + ".tree"));				
	catn("Read .tree file at generation: " + sim.generation);
	
	// Sampling
	TS1  = sim.generation + 1;   // for TS=1 after burn-in phase;
	defineConstant("T0", TS1);
	
	TS2  = T0 + tau;    		     // for TS=2
	TS2b = TS2 -1;  	           // for ONE generation BEFORE TS=2
	
	// Set the generations for each event - it schedule script blocks
	sim.rescheduleScriptBlock(s1, start = TS1, end = TS1);
	sim.rescheduleScriptBlock(s2, start = TS1, end = TS1);
	sim.rescheduleScriptBlock(s3, start = TS1, end = TS1);
	sim.rescheduleScriptBlock(s4, start = TS1, end = TS1);
	
	sim.rescheduleScriptBlock(s5, start = (T0+1), end = (T0+1)); 
	sim.rescheduleScriptBlock(s6, start = (T0+2), end = TS2);
	
	//sim.rescheduleScriptBlock(s4, start = TS1, end = TS2); // genetic load from TS1 to T2 - original
	sim.rescheduleScriptBlock(s7, start = TS1, end = TS2);
	
	sim.rescheduleScriptBlock(s8, start = TS2b, end = TS2b);
	sim.rescheduleScriptBlock(s9, start = TS2, end = TS2);
	
	m1.convertToSubstitution = F; // the effect of its change affect the next generation
	m2.convertToSubstitution = F;
	m3.convertToSubstitution = F;
	m4.convertToSubstitution = F;

	CS1 = asInteger(N + SS1);   // CS1 = the Census Size of T=1 - the effect of it change affect the next generation - 
	p1.setSubpopulationSize(CS1);
	cat("N = " + N + "\t" + "'Census Size 1' = " + CS1 + "\n");
}

//fitness(m3){
//
// // convert fecundity-based selection to survival-based selection
// if (runif(1) < relFitness)
//   return 1.0;
// else
//   return 0.0;
// }

s1 2 early() {

	if (any(sim.mutationTypes == m3))
	{
		if (max(sim.subpopulations.cachedFitness(NULL)) == mean(sim.subpopulations.cachedFitness(NULL)))
		{
			geneticL = 0;
		} else {
			geneticL = (max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL));
		}	   
	} else {
		geneticL = 0;
	}
	
	// Save the generation and the genetic load
	geneticL = paste(sim.generation + "\t" + (sim.generation - T0) + "\t" + geneticL);
	
	// Output as a TXT file
	writeFile(filePath=paste0(outputpath + "slim_output_load_" + simID + ".txt"), contents=geneticL , append=T);
}

s2 late() {
	
	//////////
	// TS=1 //
	//////////

	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, size = SS1, replace = F);
	sam_inds.tag = 0;
	
	////////////////////////////////////////////
	// OUTPUT TS=1 - SAMPLED INDIVIDUALS      //
	////////////////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS1 + " " +"individuals at:") + " " +"T1 =" + " " + paste(sim.generation) + "\n");
	cat(paste0(outputpath + "slim_output_sample_t1_" + simID + ".vcf" + "\n"));
	
	// Output as a VCF file - SS1
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_sample_t1_" + simID + ".vcf"), outputMultiallelics = F); // SS1 - mutations in the sample - postprocess to remove m4 with bcftools
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it
}

s3 fitness(NULL) {
	
	// Kill sampled individuals
	if (individual.tag == 0)
	{
		return 0.0;
	} else {
		return relFitness;
	}
}

s4 late() {
	
	p1.setSubpopulationSize(N); //add this to force sbpopulation size to N
}

s5 2 early() {

	if (any(sim.mutationTypes == m3)){
		if (max(sim.subpopulations.cachedFitness(NULL)) == mean(sim.subpopulations.cachedFitness(NULL)))
		{
			geneticL = 0;
		} else {
			geneticL = ((max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL))) * ((N+SS1)/N);
		}	  
	} else {
		geneticL = 0;
	}
	
	// Save the generation and the genetic load
	geneticL = paste(sim.generation + "\t" + (sim.generation - T0) + "\t" + geneticL);
	
	// Output as a TXT file
	writeFile(filePath=paste0(outputpath + "slim_output_load_" + simID + ".txt"), contents=geneticL , append=T);
}

s6 2 early() {
	
	///////////////////////////////////
	// OUTPUT Tx:TS2 - GENETIC LOAD  //
   ///////////////////////////////////
	
	//if (any(sim.mutationTypes == m3)){
		
	//	cchdfitnss = sim.subpopulations.cachedFitness(NULL);
	//	cchdfitnss = cchdfitnss[which(cchdfitnss != 0.0)];
	//	
	//	if (max(cchdfitnss) == mean(cchdfitnss))
	//		geneticL = 0;
	//	else
	//	   geneticL = (max(cchdfitnss) - mean(cchdfitnss))/max(cchdfitnss);
	//} else {
	//	geneticL = 0;
	//}
	
	if (any(sim.mutationTypes == m3)){
		if (max(sim.subpopulations.cachedFitness(NULL)) == mean(sim.subpopulations.cachedFitness(NULL)))
		{
			geneticL = 0;
		} else {
			geneticL = (max(sim.subpopulations.cachedFitness(NULL)) - mean(sim.subpopulations.cachedFitness(NULL)))/max(sim.subpopulations.cachedFitness(NULL));
		}   
	} else {
		geneticL = 0;
	}
	
	// Save the generation and the genetic load
	geneticL = paste(sim.generation + "\t" + (sim.generation - T0) + "\t" + geneticL);
	
	// Output as a TXT file
	writeFile(filePath=paste0(outputpath + "slim_output_load_" + simID + ".txt"), contents=geneticL , append=T);
}

s7 2 late() {

	////////////////////////////////////////////////////////////////////////////////
	// OUTPUT TS1:TS2 - POPULATION ALLELE FREQUENCIES - GENOME & EXTRA CHROMOSOME //
   ////////////////////////////////////////////////////////////////////////////////

	// GENOME
	//................
	
	// Take all the mutation EXCEPT m4's in the population
	pop_genome = sortBy(unique(sim.mutations), "position");
	pop_genome = pop_genome[which(pop_genome.mutationType != m4)];
		
	// Save the population allele frequence of the alternative allele - PAAF
	paaf_lines = sapply(pop_genome, "paste(c((applyValue.position+1), applyValue.id, applyValue.mutationType.id, applyValue.originGeneration, applyValue.selectionCoeff,  sim.mutationFrequencies(subpops=NULL,mutations=applyValue), (1 - sim.mutationFrequencies(subpops=NULL,mutations=applyValue)), 1 - ( (sim.mutationFrequencies(subpops=NULL,mutations=applyValue))^2 + (1 - sim.mutationFrequencies(subpops=NULL,mutations=applyValue))^2 ),'\\n'), '\\t');");
	
	// prepare the output table
	paaf_file = paste(paaf_lines, "");
	paaf_file = paste("POS"+"\t"+"MID"+"\t"+"MT"+"\t"+"GO"+"\t"+paste0("S" + (sim.generation - T0))+"\t"+paste0("PAAF" + (sim.generation - T0))+"\t"+paste0("PRAF" + (sim.generation - T0))+"\t"+paste0("HE" + (sim.generation - T0))+"\n")+paaf_file;
	
	// output as a TXT file - CS1
	writeFile(filePath=paste0(outputpath + "slim_output_paaf_t" + (sim.generation - T0) + "_" + simID + ".txt"), contents=paaf_file, append=F); // CS1 freq

	// EXTRA CHROMOSOME
	//..................
	
	// Take ONLY m4's in the population
	pop_extraChr = sortBy(unique(sim.mutationsOfType(m4)), "position");
	
	paaf_lines_extraChr = sapply(pop_extraChr, "paste(c((applyValue.position+1), applyValue.id, applyValue.mutationType.id, applyValue.originGeneration, sim.mutationFrequencies(subpops=NULL,mutations=applyValue), (1 - sim.mutationFrequencies(subpops=NULL,mutations=applyValue)), 1 - ( (sim.mutationFrequencies(subpops=NULL,mutations=applyValue))^2 + (1 - sim.mutationFrequencies(subpops=NULL,mutations=applyValue))^2 ),'\\n'), '\\t');"); 

	// prepare the output table
	paaf_file_extraChr = paste(paaf_lines_extraChr, "");
	paaf_file_extraChr = paste("POS"+"\t"+"MID"+"\t"+"MT"+"\t"+"GO"+"\t"+paste0("PAAF" + (sim.generation - T0))+"\t"+paste0("PRAF" + (sim.generation - T0))+"\t"+paste0("HE" + (sim.generation - T0))+"\n")+paaf_file_extraChr;
	
	// output as a TXT file - CS1
	writeFile(filePath=paste0(outputpath + "slim_output_paaf_extraChr_t" + (sim.generation - T0) + "_" + simID + ".txt"), contents=paaf_file_extraChr, append=F); // CS1 - output PAF only for all m4 - extra chr
	
	// PEDIGREE EFFECTIVE SIZE
	//...................
	
	uniqParents = unique(sim.subpopulations.individuals.pedigreeParentIDs);
	
	gametes = sapply(uniqParents, "countGametes(applyValue);"); // k => Gamete contribution of each parente (g-1 individuals);

	if (size(gametes) > 1)
	{
		pedigreene = (4*p1.individualCount)/(2+var(gametes));
	} else {
		pedigreene = (4*p1.individualCount)/(2+0);
	}
	
	// Save the generation and the number of unique parentes IDs
	pedigreene = paste(sim.generation + "\t" + (sim.generation - T0) + "\t" + pedigreene);
	
	// Output as a TXT file
	writeFile(filePath=paste0(outputpath + "slim_output_pedigreeNe_" + simID + ".txt"), contents=pedigreene , append=T);
}

s8 late() {
	
	CS2 = asInteger(N + SS2); //the effect of it change affect the next generation - CS2 = Census Size 2
	p1.setSubpopulationSize(CS2);
	cat("N = " + N + "\t" + "'Census Size 2' = " + CS2 + "\n");
}

s9 late() {
	
	//////////
	// TS=2 //
	//////////

	// Tag all individuals
	sim.subpopulations.individuals.tag = 1;
	
	// Tag sampled individuals - to "kill" then later since it simulate a destructive sampling
	sam_inds = sample(sim.subpopulations.individuals, size = SS2, replace = F);
	sam_inds.tag = 0;
	
	////////////////////////////////////////////
	// OUTPUT TS=2 - SAMPLED INDIVIDUALS      //
	////////////////////////////////////////////
	
	cat("#OUT: " + " " + paste(SS2 + " " +"individuals at:") + " " +"T2 =" + " " + paste(sim.generation) + "\n");
	cat(paste0(outputpath + "slim_output_sample_t2_" + simID + ".vcf" + "\n"));
	
	// output as a VCF file - SS2
	sam_inds.genomes.outputVCF(filePath=paste0(outputpath + "slim_output_sample_t2_" + simID + ".vcf"), outputMultiallelics = F); // SS2 - mutations in the sample - postprocess to remove m4 with bcftools
	// outputMultiallelics = F ensure no redundant mutations - change it when egglib summstats work with it
	
	sim.simulationFinished();
}
 



